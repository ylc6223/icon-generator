# 产品决策记录
## Icon Extractor - 设计选项与决策历史

**创建日期:** 2025-01-12
**最后更新:** 2025-01-12
**用途:** 记录产品设计过程中的关键决策和备选方案，为未来迭代提供参考

---

## 文档说明

本文档记录了产品设计阶段的所有访谈问题、用户选择的方案以及未被选择但值得保留的选项。每个决策都包含：
- **最终选择:** 用户确定的方案
- **备选方案:** 其他可选方案（可能在未来考虑）
- **决策理由:** 为什么做出这个选择
- **重新考虑时机:** 什么情况下应该重新评估这个决策

---

## 决策 1: 图标检测容错性

### 问题
对于图标检测的准确性，如何处理非完美的等距排列？例如，如果图标之间有轻微的间距不均匀或偏移。

### 最终选择
**网格预设+微调** - 用户提供行列数（如4x4），应用按网格切分，然后提供可视化编辑器让用户微调每个图标的边界

### 备选方案

#### A. 完全自动检测
**描述:** 应用自动尝试识别图标边界，但可能偶尔出错，用户可以手动调整边界框

**优点:**
- 用户体验更自动化
- 对于规则排列的图片无需手动输入行列数

**缺点:**
- 算法复杂度高
- 可能出现检测错误，反而增加用户工作
- 不确定性让用户不安

**为什么不选择:**
- 目标用户是非技术设计师，简单的网格输入更可控
- AI生成的图标通常排列整齐，网格检测足够准确

**未来考虑:**
- 如果用户反馈手动输入行列数太麻烦，可以添加"自动检测"按钮作为可选功能
- v2.0可以提供混合模式：默认网格，检测失败时提示自动检测

#### B. AI辅助检测
**描述:** 使用计算机视觉/AI自动识别图标区域，不依赖网格，对不规则排列也能处理，但处理时间较长

**优点:**
- 可以处理非规则排列
- 对复杂场景适应性强

**缺点:**
- 处理时间长
- 需要网络连接或加载大型AI模型
- 增加复杂度和成本

**为什么不选择:**
- 主要场景是AI生成的整齐图标，不需要复杂的AI检测
- WebAssembly的Potrace已经足够
- 本地处理，无需网络

**未来考虑:**
- 作为高级功能提供，针对非AI生成的图标
- v3.0可能考虑，当用户需要处理手绘或扫描的图标时

#### C. 混合模式
**描述:** 默认使用网格快速切分，如果用户发现某个图标质量不好，可以单独对该图标使用AI重新检测

**优点:**
- 结合了速度和准确性
- 按需使用AI，不影响常规流程

**缺点:**
- 实现复杂度高
- 用户可能困惑什么时候用哪种模式

**为什么不选择:**
- MVP阶段保持简单
- 网格+手动微调已经足够应对大多数情况

**未来考虑:**
- v2.0可以作为"高级模式"提供
- 给用户更多控制权

---

## 决策 2: 矢量化质量控制

### 问题
关于矢量化（位图转SVG）的质量控制，希望给用户多大程度的控制权？

### 最终选择
**预设模式** - 提供3-5个预设（如'清晰'、'平衡'、'精细'），每个预设对应不同的参数组合，用户不需要理解技术细节

### 备选方案

#### A. 专家模式
**描述:** 除了预设外，还提供高级参数控制（如曲线平滑度、颜色简化、细节阈值等），满足专业用户需求

**优点:**
- 专业用户有更多控制权
- 可以针对特定图标优化

**缺点:**
- 增加UI复杂度
- 非技术用户可能被吓到
- 需要文档解释每个参数

**为什么不选择:**
- 目标用户是非技术设计师，简单优先
- 3个预设应该覆盖80%的使用场景
- 避免选项过多导致选择困难

**未来考虑:**
- 可以在v2.0添加"高级选项"折叠面板
- 默认隐藏，用户可以展开查看
- 基于10%的高级用户需求决定

#### B. 实时预览+对比
**描述:** 在导出前，用户可以并排对比不同预设的矢量化效果，甚至可以点击某个图标查看放大后的路径细节

**优点:**
- 用户可以做出更好的选择
- 提高对结果的信心

**缺点:**
- 增加开发和维护成本
- 可能让流程变复杂

**为什么不选择:**
- MVP提供侧边预览面板已经足够
- 用户可以切换预设后重新矢量化

**未来考虑:**
- 如果用户反馈难以选择预设，可以添加"快速对比"功能
- 在侧边面板显示同一图标的3个预设对比

#### C. 智能推荐
**描述:** 应用分析原图的特点（如图标大小、复杂度），自动推荐最合适的矢量化参数

**优点:**
- 减少用户决策负担
- 提供个性化的建议

**缺点:**
- 推荐算法可能不准确
- 用户可能不信任推荐

**为什么不选择:**
- AI生成的图标风格通常一致，预设"平衡"已经足够
- 避免过度自动化

**未来考虑:**
- v2.0可以添加"智能推荐"作为辅助功能
- 显示推荐理由，让用户理解为什么推荐这个预设

---

## 决策 3: 边界微调的编辑体验

### 问题
关于边界微调的编辑体验，希望提供哪些功能？

### 最终选择
**拖拽调整** - 可以在原图上直接拖拽边界框的四个角和边来调整大小

### 备选方案

#### A. 数值编辑+拖拽
**描述:** 除了拖拽，还可以输入精确的像素坐标、宽高数值

**优点:**
- 满足需要精确控制的用户
- 可以进行批量调整

**缺点:**
- 增加UI复杂度
- 大多数用户不需要像素级的精确度

**为什么不选择:**
- 视觉调整对设计师更直观
- 拖拽已经满足99%的场景

**未来考虑:**
- 可以在选中边界框时，在属性面板显示数值
- 允许高级用户直接编辑

#### B. 批量操作
**描述:** 支持选择相邻图标进行批量调整，例如统一增加内边距

**优点:**
- 提高批量处理效率
- 对于多个图标需要统一调整的场景很有用

**缺点:**
- 增加交互复杂度
- 可能导致误操作

**为什么不选择:**
- MVP保持简单
- 用户可以逐个调整，对于AI图标网格通常不需要

**未来考虑:**
- v2.0如果用户反馈需要，可以添加"批量调整"面板
- 提供"统一内边距"、"统一外边距"等快捷操作

#### C. 放大对齐
**描述:** 在拖拽时显示10倍放大的像素网格，确保精确对齐到图标边缘

**优点:**
- 对于小图标或复杂边界很有帮助
- 确保高精度

**缺点:**
- 开发复杂度高
- 大多数场景不需要

**为什么不选择:**
- 视觉预览已经足够
- 避免过度工程

**未来考虑:**
- 可以在"高级模式"中提供
- 或者按住Shift键时显示放大镜

---

## 决策 4: 预览机制

### 问题
用户在导出前需要预览矢量化效果，希望的预览方式是？

### 最终选择
**侧边对比预览** - 用户点击某个图标，弹窗显示原图和SVG的并排对比，可以放大查看细节

### 备选方案

#### A. 悬停预览
**描述:** 在一个画布上同时看到所有图标的缩略图，悬停时快速预览矢量化效果

**优点:**
- 快速浏览所有图标
- 效率高

**缺点:**
- 不适合详细对比
- 移动端体验差

**为什么不选择:**
- 用户需要仔细对比质量，悬停预览不够深入
- 侧边预览可以同时看到多个信息（文件大小、节点数等）

**未来考虑:**
- 可以在图标列表中显示小的矢量化预览缩略图
- 悬停时显示，点击打开详细预览

#### B. 选择性处理
**描述:** 每个图标缩略图下方有小勾选框，只有选中的图标才会被处理和导出，节省时间

**优点:**
- 用户可以只处理需要的图标
- 节省时间

**缺点:**
- 增加一步操作
- 可能让用户困惑

**为什么不选择:**
- MVP保持简单，默认处理所有图标
- 导出时可以选择不需要的图标

**未来考虑:**
- 可以在导出面板添加"排除图标"功能
- 或者在图标列表添加勾选框

#### D. 单图标重试
**描述:** 对于质量不满意的图标，用户可以点击'重新处理'按钮，应用仅重新处理该图标

**优点:**
- 针对性解决问题
- 不需要重新处理所有图标

**缺点:**
- 增加UI复杂度

**为什么不选择:**
- 用户可以调整预设后重新矢量化所有图标（WebAssembly很快）
- MVP保持简单

**未来考虑:**
- v2.0可以添加"单图标重试"
- 或者"重新处理选中的图标"

---

## 决策 5: 导出文件命名

### 问题
对于导出的SVG文件命名，倾向于哪种方式？

### 最终选择
**自定义标签** - 用户可以在导出前为每个图标添加标签/备注，导出时使用这些标签作为文件名

### 备选方案

#### A. 数字编号
**描述:** icon-1.svg, icon-2.svg... 简单直接

**优点:**
- 实现简单
- 不会重复

**缺点:**
- 没有语义信息
- 用户需要手动重命名

**为什么不选择:**
- 用户体验差
- 导出后还需要手动重命名很麻烦

#### B. 语义命名
**描述:** 使用OCR或用户输入的文件名，如 'home-icon.svg', 'user-icon.svg'

**优点:**
- 有语义信息
- 方便使用

**缺点:**
- OCR不准确
- 需要用户输入

**为什么不选择:**
- OCR技术复杂且不准确
- 自定义标签更直接

**未来考虑:**
- v2.0的AI标签生成功能会提供智能命名建议
- 用户可以接受或修改建议

#### C. 网格坐标命名
**描述:** 保持原有行列信息，如 'row-1-col-1.svg', 'row-3-col-2.svg'

**优点:**
- 保留位置信息
- 不容易重复

**缺点:**
- 没有语义
- 用户难以使用

**为什么不选择:**
- 不如自定义标签灵活
- 数字编号更简单

**未来考虑:**
- 可以在导出时生成一个index.html，预览所有图标并显示坐标信息
- 作为可选的导出格式

---

## 决策 6: 批量处理工作流

### 问题
如果用户需要处理多个大图（例如多个设计稿），希望的工作流程是？

### 最终选择
**单图模式** - 不支持多图上传，保持简单，用户处理完一个图后可以清空工作区重新开始

### 备选方案

#### A. 多图合并导出
**描述:** 用户可以一次选择多个大图上传，应用按顺序处理，最后统一导出一个包含所有图标的ZIP

**优点:**
- 批量处理效率高
- 一次导出所有图标

**缺点:**
- 界面复杂度增加
- 需要管理多个图片的状态
- 可能混淆

**为什么不选择:**
- MVP保持简单
- 单图模式已经满足核心需求
- 避免过度设计

**未来考虑:**
- v2.0如果用户需求强烈，可以添加"多图模式"
- 使用标签页或项目概念管理多个图片

#### B. 分开导出
**描述:** 每张大图导出一个ZIP，ZIP内包含该图的所有图标

**优点:**
- 清晰的组织结构
- 用户可以单独处理每个图

**缺点:**
- 需要多次导出
- 增加操作步骤

**为什么不选择:**
- 不如单图模式简单
- 用户可以分批次处理

**未来考虑:**
- 如果添加多图模式，这是更合理的组织方式

#### C. 项目管理
**描述:** 用户可以为每个上传的大图创建一个'项目'，在项目中保存边界调整、预设选择等配置，随时回来编辑

**优点:**
- 保存工作进度
- 可以同时处理多个项目

**缺点:**
- 需要本地存储或数据库
- 增加复杂度

**为什么不选择:**
- MVP不需要
- 单图模式足够简单，不需要保存项目

**未来考虑:**
- v3.0可以考虑添加本地存储的项目功能
- 使用IndexedDB保存项目配置
- 满足需要分多次处理大量图标的用户

---

## 决策 7: 矢量化技术实现

### 问题
关于矢量化处理的技术实现方式，你的优先级是？

### 最终选择
**WebAssembly加速** - 使用WebAssembly将C++矢量化工有编译到前端运行，接近原生性能，但实现复杂度高

### 备选方案

#### A. 纯前端处理
**描述:** 完全在浏览器中使用JavaScript处理，无需服务器，数据私密，但处理速度较慢且受设备性能限制

**优点:**
- 实现简单
- 无需编译Wasm
- 兼容性好

**缺点:**
- 性能较差
- 大量图标可能卡顿

**为什么不选择:**
- 用户体验优先
- WebAssembly性能提升显著（3-10倍）
- 现代浏览器都支持Wasm

**未来考虑:**
- 实现时提供JavaScript降级方案
- 检测Wasm支持，不支持时使用JS版本

#### B. 服务端处理
**描述:** 上传到服务器使用专业的矢量化工具有（如Potrace、Vectorization Magic API），速度快质量高，但需要网络和隐私权衡

**优点:**
- 可以使用最先进的算法
- 服务器性能更强
- 可以使用付费API

**缺点:**
- 隐私顾虑
- 需要网络连接
- 运营成本

**为什么不选择:**
- 隐私是核心价值
- 本地处理更符合产品定位
- 避免运营成本

**未来考虑:**
- 可以作为可选的高级功能
- 用户可以选择"云处理"获得更好的质量
- freemium模式：本地免费，云端付费

#### C. 混合模式
**描述:** 默认前端处理，如果处理时间过长或用户需要更高质量，提供选项上传到服务端处理

**优点:**
- 兼顾性能和质量
- 给用户选择权

**缺点:**
- 实现两套系统
- 增加复杂度

**为什么不选择:**
- MVP保持简单
- Wasm性能已经足够好

**未来考虑:**
- v2.0可以提供"云端优化"作为可选功能
- 针对需要更高质量的专业用户

---

## 决策 8: 质量保证机制

### 问题
如果某个图标矢量化后质量明显不佳（例如路径混乱、细节丢失），应用应该如何处理？

### 最终选择
**仅警告** - 显示警告但不阻止导出，让用户自己决定

### 备选方案

#### A. 视觉标记
**描述:** 在列表中用图标标记低质量图标，但仍然允许导出

**优点:**
- 用户可以一眼看到问题
- 不打断流程

**缺点:**
- 可能被忽略
- 不如警告明显

**为什么不选择:**
- "仅警告"已经包含了视觉标记（警告图标）
- 额外的标记可能让界面混乱

**未来考虑:**
- 可以在图标列表上显示小的警告图标
- 点击查看详细警告信息

#### B. 质量评分
**描述:** 显示质量评分（如85分），让用户了解每个图标的矢量化质量

**优点:**
- 量化质量
- 用户可以快速判断

**缺点:**
- 评分算法可能不准确
- 用户可能过度关注分数

**为什么不选择:**
- 评分可能误导用户
- 警告信息比分数更有用

**未来考虑:**
- 可以在详细信息中显示"质量评分"
- 作为参考信息，不作为主要指标

#### C. 强制限制
**描述:** 阻止导出低质量图标，直到用户调整边界或更换预设重新处理

**优点:**
- 保证导出质量
- 维护产品声誉

**缺点:**
- 用户可能感到受限
- 可能无法满足特殊需求

**为什么不选择:**
- 用户应该有最终决定权
- 一些"质量问题"可能是故意的（如艺术风格）
- 避免过度保护

**未来考虑:**
- 可以添加"严格模式"选项
- 启用后会阻止导出低质量图标

---

## 决策 9: 目标用户群体

### 问题
这个应用的主要目标用户群体是？

### 最终选择
**非技术设计师** - UI应该简单直观，避免技术术语，一键操作，快速上手

### 备选方案

#### A. 专业开发者
**描述:** 提供快捷键、高级参数选项、批量操作等效率工具

**优点:**
- 用户群体大
- 付费意愿强

**缺点:**
- 需求更复杂
- 竞争激烈

**为什么不选择:**
- 差异化优势在于简单
- 开发者可能更喜欢命令行工具或Figma插件

**未来考虑:**
- 可以提供API供开发者集成
- 或提供CLI工具

#### B. 混合用户群
**描述:** 平衡易用性和功能性，有简单的默认界面，也有'高级'开关展开更多选项

**优点:**
- 覆盖更广的用户
- 满足不同需求

**缺点:**
- 设计复杂度增加
- 可能两边都不讨好

**为什么不选择:**
- MVP阶段聚焦
- 先服务好一个核心用户群

**未来考虑:**
- v2.0可以添加"高级模式"开关
- 默认简单界面，高级用户可以展开更多选项

---

## 决策 10: 图片来源类型

### 问题
预期用户上传的大图主要来源是什么类型？

### 最终选择
**AI生成图标** - 如AI图标生成工具的输出，图标风格统一，尺寸一致

### 备选方案

#### A. 专业设计稿
**描述:** 如设计师导出的图标资源页，可能经过人工优化，排列整齐

**优点:**
- 质量通常较高
- 排列整齐

**为什么不选择:**
- 与AI生成图标的特征相似
- 网格检测都适用

**未来考虑:**
- 产品定位可以扩展到"等距图标提取"
- 不仅限于AI生成的图标

#### B. 混合来源
**描述:** 从各种来源收集的图标，质量参差不齐，需要大量手动调整

**优点:**
- 用户群更广

**缺点:**
- 处理难度大
- 边界情况多

**为什么不选择:**
- MVP聚焦最常见的场景
- 避免过度复杂

**未来考虑:**
- 如果数据显示用户有其他来源，可以扩展
- 添加"智能检测"处理非规则排列

#### C. 扫描件/手绘
**描述:** 扫描的手绘图标、线稿等，可能有噪点和不规则边界

**优点:**
- 独特场景

**缺点:**
- 需要额外的预处理（去噪、二值化）
- 不是主要需求

**为什么不选择:**
- 不是核心场景
- 需要专门的功能

**未来考虑:**
- 可以作为专门的"手绘图标模式"
- v3.0可能考虑

---

## 决策 11: 核心差异化优势

### 问题
与Figma、Illustrator等现有工具相比，这个应用的核心差异化优势应该是？

### 最终选择
**极致简单** - 极简的UI，3步完成：上传->微调->导出，比Figma/Illustrator更快

### 备选方案

#### A. 隐私+免费
**描述:** 完全免费且无需注册，处理后的图标无版权限制

**优点:**
- 吸引用户
- 无隐私顾虑

**为什么不选择:**
- 这是基础要求，不是差异化优势
- "极致简单"更独特

**未来考虑:**
- 作为重要的营销信息强调
- 但核心差异化仍然是简单

#### B. AI场景优化
**描述:** 专为AI图标优化，针对AI输出的特点（如渐变、阴影）进行特殊处理

**优点:**
- 垂直领域优势

**为什么不选择:**
- AI图标通常已经是扁平的，不需要特殊处理
- 简单更重要

**未来考虑:**
- 可以在营销材料中强调
- 作为细分市场的优势

#### C. 工作流集成
**描述:** 集成命名、批量优化、风格统一等图标工作流所需的完整工具集

**优点:**
- 功能全面

**为什么不选择:**
- 与"极致简单"冲突
- MVP聚焦核心功能

**未来考虑:**
- v2.0可以逐步添加工作流工具
- 但保持简单易用

---

## 决策 12: 未来扩展功能优先级

### 问题
在基础功能之上，哪些未来扩展功能比较重要？

### 最终选择
**多选：AI标签生成 + 自动裁剪**

### 备选方案

#### A. 样式批量编辑
**描述:** 导出时调整所有图标的统一颜色、大小、描边粗细等

**优点:**
- 实用性强
- 提高工作效率

**为什么不选择（现在）:**
- MVP阶段聚焦核心功能
- 需要SVG编辑能力，复杂度较高

**未来考虑:**
- v2.5或v3.0可以考虑
- 用户反馈强烈时优先开发

#### B. 多格式导出
**描述:** 支持导出为PNG、WebP等其他格式，或导出为Icon Font、React组件等

**优点:**
- 满足不同需求

**为什么不选择（现在）:**
- SVG是最通用的格式
- 其他格式可以通过工具转换

**未来考虑:**
- 可以提供导出模板
- 或集成第三方工具

---

## 决策矩阵总结

| 决策点 | 最终选择 | 关键原因 | 重新考虑时机 |
|--------|----------|----------|--------------|
| 检测容错性 | 网格预设+微调 | 简单、可控、适合AI图标 | 用户反馈检测太慢时 |
| 矢量化控制 | 预设模式 | 避免技术复杂度 | 专业用户需求强烈 |
| 边界编辑 | 拖拽调整 | 直观、满足99%场景 | 需要精确控制时 |
| 预览方式 | 侧边对比 | 详细、信息丰富 | 需要快速浏览时 |
| 文件命名 | 自定义标签 | 用户友好、有意义 | 用户想要自动化 |
| 批量处理 | 单图模式 | 保持简单 | 多图处理需求强烈 |
| 技术实现 | WebAssembly | 性能优先 | Wasm不支持率高于5% |
| 质量保证 | 仅警告 | 用户自主权 | 质量问题导致投诉时 |
| 目标用户 | 非技术设计师 | 差异化 | 需要扩展市场时 |
| 图片来源 | AI生成图标 | 垂直场景 | 其他来源需求增加 |
| 核心优势 | 极致简单 | 独特卖点 | 竞品模仿时 |
| 扩展功能 | AI标签+自动裁剪 | 高价值 | 用户需求变化时 |

---

## 决策原则

在未来的产品迭代中，做决策时应遵循以下原则：

1. **简单优先**: 当功能性和简单性冲突时，优先选择简单
2. **用户自主权**: 让用户做最终决定，而不是强制
3. **渐进增强**: 先实现核心功能，再添加高级选项
4. **数据驱动**: 基于用户反馈和使用数据做决策，而不是假设
5. **保持聚焦**: 避免功能蔓延，始终围绕核心价值

---

## 重新评估流程

当需要重新评估某个决策时：

1. **收集数据**: 用户反馈、使用数据、竞品分析
2. **分析影响**: 对用户体验、开发成本、维护成本的影响
3. **评估收益**: 是否显著提升产品价值
4. **考虑替代**: 是否有更好的解决方案
5. **小步验证**: 通过A/B测试或用户访谈验证
6. **文档更新**: 更新本文档，记录新的决策

---

## 附录：未被采纳但有价值的想法

即使最终没有选择，这些想法在未来可能有用：

### 高价值备选方案
1. **项目管理** - 对于需要处理大量图标的用户很有价值
2. **WebAssembly + 混合模式** - 提供云端优化作为高级功能
3. **批量操作** - 如果用户需要处理多个图标时
4. **智能推荐** - 帮助用户选择合适的预设
5. **高级模式** - 满足专业用户需求，同时保持简单

### 值得保留的设计思路
1. **可视化反馈** - 所有操作都应该有即时的视觉反馈
2. **渐进披露** - 默认简单，高级选项可展开
3. **智能默认** - 基于AI图标的特点预设合理值
4. **本地优先** - 保护隐私，快速响应

---

## 技术备选方案价值评估

以下是对所有技术决策中未被选中方案的价值评估，用于未来迭代优先级参考：

### 🔥 高优先级（v2.0强烈推荐）

1. **IndexedDB项目持久化**
   - **价值:** 用户反馈数据丢失是最常见抱怨
   - **场景:** 用户处理到一半意外关闭浏览器
   - **实现成本:** 中等（2-3天）
   - **影响:** 显著提升用户体验

2. **fflate替换JSZip**
   - **价值:** 减小打包体积92KB（~100KB → ~8KB）
   - **场景:** 用户首次加载页面
   - **实现成本:** 低（1天，API相似）
   - **影响:** 更快的首次加载

3. **自适应Worker数量**
   - **价值:** 高性能设备获得更好体验
   - **场景:** 用户在高端Mac/PC上处理大量图标
   - **实现成本:** 低（1天）
   - **影响:** 部分用户体验提升3-4倍

### 💡 中优先级（v2.5-3.0考虑）

4. **Canvas虚拟渲染**
   - **价值:** 支持100+图标不卡顿
   - **场景:** 用户处理超大网格（如10x10=100图标）
   - **实现成本:** 高（5-7天）
   - **影响:** 扩展使用场景上限

5. **命令模式撤销系统**
   - **价值:** 支持全局撤销/重做
   - **场景:** 用户误操作网格设置、标签等
   - **实现成本:** 中高（需要重构状态管理，5-7天）
   - **影响:** 更好的容错性

6. **Potrace + VTracer双引擎**
   - **价值:** 用户可以选择更适合的算法
   - **场景:** 黑白图标用Potrace效果更好
   - **实现成本:** 中（3-4天）
   - **影响:** 提升矢量化质量

7. **Blob URL存储大图片**
   - **价值:** 减少内存占用50%
   - **场景:** 用户处理4096x4096大图
   - **实现成本:** 中（需要生命周期管理，3天）
   - **影响:** 支持更大的图片

8. **高级进度显示（可选）**
   - **价值:** 满足专业用户需求
   - **场景:** 开发者/高级用户查看详细信息
   - **实现成本:** 低（1天）
   - **影响:** 提升透明度

### 🌟 低优先级（长期考虑）

9. **SVG内容清理（DOMPurify）**
   - **价值:** 提升安全性（如果支持用户上传SVG）
   - **场景:** 未来功能扩展
   - **实现成本:** 低（1天）
   - **影响:** 安全性增强

10. **完整测试覆盖（E2E）**
    - **价值:** 保证质量，防止回归
    - **场景:** 产品成熟后维护
    - **实现成本:** 高（持续维护）
    - **影响:** 长期稳定性

11. **响应式设计（平板支持）**
    - **价值:** 扩大用户群体
    - **场景:** 设计师使用iPad
    - **实现成本:** 中（3-4天）
    - **影响:** 增加可用性

12. **更多图片格式（AVIF/HEIC）**
    - **价值:** 支持更多来源
    - **场景:** iOS用户、现代相机输出
    - **实现成本:** 中（需要额外库，3天）
    - **影响:** 兼容性提升

### ❌ 不推荐（成本高收益低）

1. **严格质量阈值** - 会增加误报，用户体验下降
2. **无限撤销历史** - 内存不可控，性能问题
3. **全局状态持久化** - localStorage限制5MB，IndexedDB过于复杂
4. **Sentry监控** - 与隐私理念冲突，用户不信任
5. **详细日志模式** - 信息过载，普通用户不需要
6. **移动端全响应式** - 使用场景少，开发成本高

---

## 技术债务清单

以下是MVP阶段有意保留的技术简化，未来需要偿还：

### 性能优化债务
- [ ] Canvas渲染未优化（虚拟渲染/图层分离）
- [ ] 固定4个Worker未自适应
- [ ] 图片存储使用Canvas引用而非最优Blob URL
- [ ] 未实现图片懒加载

### 用户体验债务
- [ ] 无状态持久化（刷新丢失数据）
- [ ] 撤销历史仅5步且仅边界框
- [ ] 无操作历史面板
- [ ] 无快捷键（Delete/Esc等）

### 安全性债务
- [ ] SVG未清理（如支持用户上传需添加）
- [ ] 无CSP策略（Content Security Policy）
- [ ] 输入验证较宽松

### 功能完整性债务
- [ ] 仅桌面设备优化
- [ ] 无批量边界调整
- [ ] 无智能标签建议
- [ ] 无多图处理模式

---

## 迭代建议时间表

### v2.0 (发布后2-3个月)
**目标:** 解决最常见用户抱怨
1. IndexedDB项目持久化（防止数据丢失）
2. fflate替换JSZip（减小体积）
3. 自适应Worker数量（提升性能）
4. 高级进度显示选项
5. 标签智能建议和批量重命名

### v2.5 (发布后6个月)
**目标:** 扩展使用场景
1. Canvas虚拟渲染（支持100+图标）
2. 平板响应式优化
3. Potrace + VTracer双引擎选择
4. 批量边界调整
5. 更完整的撤销/重做系统

### v3.0 (发布后12个月)
**目标:** 平台化
1. 多图处理模式
2. 云端优化服务（可选）
3. AI标签生成
4. 自动裁剪
5. 开放API（供开发者集成）
6. 本地桌面应用（Electron/Tauri）

---

**文档维护:**
- 每次产品重大变更时更新
- 记录决策变更的原因
- 定期回顾（每季度）是否需要重新评估某些决策
- 根据用户反馈调整"高优先级"列表

**下次回顾日期:** 2025-04-12 (MVP发布后3个月)

## 技术实现决策

以下决策是通过技术深度访谈确定的，涉及具体的技术实现细节。

### 决策 13: WebAssembly矢量化库选择

### 问题
使用哪个WebAssembly矢量化库来实现位图转SVG功能？

### 最终选择
**VTracer** - 使用VTracer的WebAssembly方案，支持彩色矢量化，文档完善

### 备选方案

#### A. Potrace
**描述:** 经典的黑白矢量化库，成熟稳定

**优点:**
- 算法成熟
- 社区支持好

**缺点:**
- 只支持黑白图像
- 对彩色图标需要额外处理

**为什么不选择:**
- AI生成的图标通常是彩色的
- VTracer原生支持彩色更合适

**未来考虑 (v2.0+):**
- Potrace仍是黑白图标的首选，可以提供多种算法选项
- 如果VTracer效果不佳，可以集成多个算法让用户选择
- 考虑添加ImageTracer作为JavaScript降级方案（不需要Wasm）
- 或者混合模式：彩色用VTracer，黑白用Potrace
- v3.0可以训练自己的矢量化模型（基于AI）

#### B. ImageTracer
**描述:** JavaScript实现的矢量化库

**优点:**
- 纯JS实现，无需Wasm
- 支持彩色

**缺点:**
- 性能较差
- 大量图标处理会卡顿

**为什么不选择:**
- WebAssembly性能更好
- 用户体验优先

---

### 决策 14: 状态持久化策略

### 问题
是否需要保存用户的编辑状态（如边界框调整、标签等），以便刷新页面后恢复？

### 最终选择
**不持久化** - 所有状态只在内存中，刷新页面后丢失，保持极简

### 备选方案

#### A. localStorage持久化
**描述:** 保存到浏览器localStorage，刷新后自动恢复

**优点:**
- 防止意外丢失数据
- 提升用户体验

**缺点:**
- 需要序列化/反序列化
- localStorage有5MB限制

**为什么不选择:**
- 用户处理完一次就导出，不需要持久化
- 保持简单，减少复杂度

**未来考虑 (v2.0+):**
- 如果用户反馈频繁意外丢失数据，可以添加sessionStorage持久化
- sessionStorage只在标签页关闭前有效，不会永久占用空间
- v2.0可以添加"保存项目"功能（使用IndexedDB，用户主动触发）
- 或者提供导出/导入配置功能（保存为JSON文件）
- 考虑实现自动保存草稿（每隔1分钟自动保存到IndexedDB）

#### B. IndexedDB持久化
**描述:** 使用IndexedDB存储大型数据和图片

**优点:**
- 容量更大
- 支持异步操作

**缺点:**
- 实现复杂
- MVP不需要

**为什么不选择:**
- 过度设计
- 不持久化已经满足需求

---

### 决策 15: WebWorker并发数量

### 问题
矢量化时使用多少个WebWorker并发处理？

### 最终选择
**保守（4个Worker）** - 平衡性能和资源占用，适合大多数设备

### 备选方案

#### A. 激进（8个Worker）
**描述:** 最大化并发，提升处理速度

**优点:**
- 处理更快
- 适合高性能设备

**缺点:**
- 低端设备可能卡顿
- 内存占用高

**为什么不选择:**
- 考虑到设备多样性
- 4个Worker已经足够快

**未来考虑 (v2.0+):**
- 实现性能基准测试，自动检测最佳Worker数量
- 可以在设置中提供Worker数量选项（2/4/8/自动）
- "自动"模式根据CPU核心数和设备性能动态调整
- 高性能设备默认使用8个，低端设备使用2个
- 或者实现自适应：监控处理速度，动态增减Worker数量

#### B. 自适应
**描述:** 根据设备CPU核心数动态调整Worker数量

**优点:**
- 最优性能
- 适应不同设备

**缺点:**
- 实现复杂
- 需要额外的检测逻辑

**为什么不选择:**
- MVP保持简单
- 固定4个足够

---

### 决策 16: 图片数据存储格式

### 问题
如何存储上传的图片数据？

### 最终选择
**Canvas引用** - 保持Canvas元素引用，按需提取数据，平衡内存和性能

### 备选方案

#### A. Base64字符串
**描述:** 立即转换为base64字符串存储

**优点:**
- 简单直接
- 易于传递

**缺点:**
- 内存占用大（约33%增长）
- 大图片可能导致内存压力

**为什么不选择:**
- 4096x4096的图片转base64后约16MB
- Canvas引用更高效

#### B. Blob URL
**描述:** 创建Blob对象和Object URL

**优点:**
- 内存占用最小
- 适合大文件

**缺点:**
- 需要手动revoke防止内存泄漏
- 增加生命周期管理复杂度

**为什么不选择:**
- Canvas引用足够高效
- 避免内存泄漏风险

**未来考虑 (v2.0+):**
- 如果用户反馈内存占用过高（如处理100+图标时），可以考虑使用Blob URL
- 需要实现完善的Blob生命周期管理，确保及时revoke
- 可以提供"内存优化模式"选项，在大图片时自动使用Blob URL
- 或者混合方案：小图片用Canvas引用，大图片（>2048x2048）用Blob URL

#### C. ImageData对象
**描述:** 直接存储Canvas的ImageData

**优点:**
- 像素级访问
- 性能最佳

**缺点:**
- 内存占用最大
- 只能在Worker中使用

**为什么不选择:**
- 不需要在主线程存储ImageData
- Canvas引用更灵活

---

### 决策 17: 撤销/重做历史深度

### 问题
支持多少步撤销历史？

### 最终选择
**5步** - 有限的撤销历史，平衡内存和功能性

### 备选方案

#### A. 10步或更多
**描述:** 提供更多的撤销机会

**优点:**
- 更安全
- 用户可以大胆尝试

**缺点:**
- 内存占用更高
- 大多数场景用不到

**为什么不选择:**
- 边界框调整通常不需要那么多步
- 5步已经覆盖大多数错误

**未来考虑 (v2.0+):**
- 如果用户反馈5步不够，可以增加为10步
- 或者提供可配置的撤销历史深度（高级设置）
- 另一个方向：实现智能撤销，合并微小操作
- 可以添加"重要操作确认"对话框，减少撤销需求

#### B. 无限历史
**描述:** 不限制撤销步数

**优点:**
- 完全自由

**缺点:**
- 内存不可控
- 可能导致性能问题

**为什么不选择:**
- 需要设置限制
- 5步是合理的折中

#### C. 不支持撤销
**描述:** 不实现撤销功能

**优点:**
- 最简单

**缺点:**
- 用户体验差
- 无法纠错

**为什么不选择:**
- 撤销是基本功能
- 提升用户体验

---

### 决策 18: SVG内容清理策略

### 问题
是否需要对生成的SVG内容进行清理（sanitize）以防止XSS攻击？

### 最终选择
**不清理** - 信任自生成的SVG，不引入清理库，减少依赖

### 备选方案

#### A. 使用DOMPurify
**描述:** 使用DOMPurify库清理SVG内容

**优点:**
- 更安全
- 防止XSS

**缺点:**
- 增加依赖（~40KB）
- 轻微性能开销
- 自生成SVG不需要

**为什么不选择:**
- SVG是应用自己生成的，不是用户输入
- 没有XSS风险
- 减少依赖

**未来考虑 (v2.0+):**
- 如果未来添加用户上传SVG功能，必须集成DOMPurify
- 或者在v2.0添加"安全模式"选项，让用户选择是否清理SVG
- 轻量级清理方案：只移除<script>标签和事件处理器
- 性能敏感场景可以考虑使用sanitize-html库（比DOMPurify更快）

#### B. 轻量级清理
**描述:** 手动实现简单的清理逻辑

**优点:**
- 控制清理规则
- 较轻量

**缺点:**
- 需要维护
- 可能遗漏风险

**为什么不选择:**
- 不需要清理
- 避免过度防御

---

### 决策 19: 错误监控策略

### 问题
是否需要集成错误监控服务（如Sentry）来跟踪运行时错误？

### 最终选择
**不监控** - 完全本地运行，不收集任何数据，保护隐私

### 备选方案

#### A. Sentry监控
**描述:** 集成Sentry进行错误跟踪

**优点:**
- 及时发现bug
- 了解错误分布

**缺点:**
- 需要账号配置
- 收集用户数据
- 与隐私理念冲突

**为什么不选择:**
- 隐私是核心价值
- MVP阶段不需要
- 增加复杂度

**未来考虑 (v2.5+):**
- 发布后如果bug较多，可以添加可选的错误报告功能
- 用户可以选择"自动发送错误报告"（需明确同意）
- 或者实现本地日志查看器，让用户自行查看和分享错误
- 轻量级方案：只在崩溃时显示错误报告对话框
- 考虑使用开源的Sentry自托管方案，保护隐私

#### B. 本地日志
**描述:** 将错误日志保存到localStorage

**优点:**
- 不收集用户数据
- 用户可以自行查看

**缺点:**
- 无法自动上报
- 需要用户主动提供

**为什么不选择:**
- 不如简单控制台日志
- 出错用户会反馈

---

### 决策 20: 测试覆盖范围

### 问题
需要测试哪些部分？

### 最终选择
**核心算法测试** - 只测试矢量化、网格检测、质量检测等核心算法

### 备选方案

#### A. 全覆盖测试
**描述:** 包括单元测试、集成测试、E2E测试

**优点:**
- 质量保证
- 重构安全

**缺点:**
- 开发时间长
- 维护成本高

**为什么不选择:**
- MVP速度优先
- 核心算法测试已经覆盖关键路径

**未来考虑 (v2.0+):**
- v2.0可以添加组件单元测试（React Testing Library）
- 重要交互添加E2E测试（Playwright或Cypress）
- CI/CD集成自动化测试（GitHub Actions）
- 测试覆盖率目标：核心模块>80%，UI组件>60%
- 视觉回归测试（Percy或Chromatic）用于UI组件

#### B. 手动测试
**描述:** 不写自动化测试，完全手动测试

**优点:**
- 最快

**缺点:**
- 回归风险高
- 质量难保证

**为什么不选择:**
- 核心算法太重要
- 需要自动化测试保证质量

---

### 决策 21: ZIP导出库选择

### 问题
使用哪个库来打包SVG文件？

### 最终选择
**JSZip** - 成熟的纯前端库，API简单，体积适中

### 备选方案

#### A. fflate
**描述:** 更轻量级的ZIP库

**优点:**
- 体积小（~8KB）
- 性能更好

**缺点:**
- API相对复杂
- 社区较小

**为什么不选择:**
- JSZip更成熟
- API更易用
- ~100KB可接受

**未来考虑 (v2.0+):**
- 如果打包体积成问题，可以考虑切换到fflate（~8KB）
- fflate性能更好（约2-3倍快），适合大量文件
- 可以提供两种导出模式：标准模式（JSZip）和小体积模式（fflate）
- 或者在v2.0实现动态导入，只在导出时加载ZIP库
- 考虑使用zip-lib（基于fflate，API更友好）

#### B. Browser原生
**描述:** 使用File System Access API

**优点:**
- 无需库

**缺点:**
- 兼容性差（仅Chrome/Edge）
- 不推荐MVP

**为什么不选择:**
- 兼容性优先
- JSZip支持所有浏览器

---

### 决策 22: Canvas渲染优化策略

### 问题
如何优化大图片和多图标场景的Canvas性能？

### 最终选择
**不做优化** - MVP阶段保持简单，实际使用中出现性能问题再优化

### 备选方案

#### A. 虚拟渲染
**描述:** 只渲染视口可见区域和选中图标

**优点:**
- 支持大量图标
- 性能好

**缺点:**
- 实现复杂
- 需要额外的渲染逻辑

**为什么不选择:**
- MVP场景通常不超过64个图标
- 先不做优化，看实际需求

**未来考虑 (v2.0+):**
- 如果用户反馈处理大图（>100图标）时卡顿，优先实现虚拟渲染
- 性能监控：如果Canvas渲染时间>16ms（60fps），触发优化
- 图层分离方案可以作为折中方案，实现简单且有效
- 降采样可以作为"性能模式"选项，让用户选择
- 考虑使用OffscreenCanvas在Worker中渲染（Chrome支持）

#### B. 图层分离
**描述:** 原图层和边界框层分开渲染

**优点:**
- 调整边界框时只重绘边界框层

**缺点:**
- 增加复杂度
- 需要管理两个Canvas

**为什么不选择:**
- 单Canvas足够
- 性能不是MVP瓶颈

#### C. 降采样
**描述:** Canvas显示时使用缩略图

**优点:**
- 节省内存

**缺点:**
- 可能显示不清晰
- 导出时才用原图

**为什么不选择:**
- 用户需要在Canvas上精确调整
- 降采样影响体验

---

### 决策 23: 质量检测阈值标准

### 问题
矢量化结果的警告触发标准是什么？

### 最终选择
**宽松标准** - 路径数>500，文件大小>50KB才警告

### 备选方案

#### A. 严格标准
**描述:** 路径数>300，文件大小>30KB即警告

**优点:**
- 捕获更多潜在问题

**缺点:**
- 误报率高
- AI图标本身可能较复杂

**为什么不选择:**
- AI生成的图标可能细节丰富
- 避免过度警告
- 宽松标准更适合

**未来考虑 (v2.0+):**
- 根据用户反馈调整阈值（收集警告点击率）
- 如果误报率>20%，考虑放宽到路径>600，大小>70KB
- 实现自适应阈值：根据图标尺寸动态调整
- 提供质量滑块让用户自定义阈值
- 考虑引入机器学习模型预测质量（需要训练数据）

#### B. 自适应标准
**描述:** 根据图标尺寸动态调整阈值

**优点:**
- 更智能
- 减少误报

**缺点:**
- 实现复杂
- 需要更多计算

**为什么不选择:**
- MVP保持简单
- 固定阈值足够

---

### 决策 24: 进度反馈粒度

### 问题
用户在处理大量图标时看到多细粒度的进度？

### 最终选择
**分步进度** - 分阶段显示进度（检测中3/16，矢量化中5/16）

### 备选方案

#### A. 整体进度
**描述:** 只显示总进度百分比（0-100%）

**优点:**
- 简洁

**缺点:**
- 不透明
- 用户不知道卡在哪

**为什么不选择:**
- 分步进度提供更多信息
- 用户体验更好

**未来考虑 (v2.0+):**
- 可以在设置中提供进度显示选项：简洁/标准/详细
- 高级用户可能喜欢详细日志，可以添加"开发者模式"
- 实现可折叠的详细日志（默认折叠，点击展开）
- 考虑添加每个图标的处理时间显示
- 批量操作时显示预估剩余时间

#### C. 详细日志
**描述:** 显示每个图标的处理时间和结果

**优点:**
- 最透明

**缺点:**
- 信息过载
- 可能干扰用户

**为什么不选择:**
- 分步进度已经足够
- 避免信息过多

---

### 决策 25: 撤销/重做实现范围

### 问题
哪些操作支持撤销？

### 最终选择
**边界框历史** - 只保存边界框的历史记录

### 备选方案

#### A. 全局历史
**描述:** 保存所有状态变化（网格设置、边界框、标签等）

**优点:**
- 更全面

**缺点:**
- 内存占用高
- 实现复杂

**为什么不选择:**
- 边界框调整是最容易出错的操作
- 其他操作不需要撤销
- 保持简单

**未来考虑 (v2.0+):**
- 如果用户强烈需求，可以扩展到网格设置的撤销
- 命令模式是更好的长期架构，v3.0重构时考虑
- 可以实现"操作历史"面板，显示所有操作记录
- 考虑添加"重置到初始状态"功能（清空所有修改）
- 或者实现"快照"功能，用户可以保存多个状态点

#### B. 命令模式
**描述:** 通过命令模式实现撤销/重做

**优点:**
- 更灵活
- 易于扩展

**缺点:**
- 实现复杂
- 不在状态管理中实现

**为什么不选择:**
- MVP简单实现
- 状态管理中存储历史即可

---

### 决策 26: 图标标签验证规则

### 问题
用户输入的标签需要什么程度的验证？

### 最终选择
**标准验证** - 字符限制+非法字符+重复检查+连续空格处理

### 备选方案

#### A. 基础验证
**描述:** 只检查文件名非法字符（/、\、:等）

**优点:**
- 最简单

**缺点:**
- 可能出现过长标签
- 可能有重复标签

**为什么不选择:**
- 重复标签会导致导出冲突
- 需要基本的质量控制

**未来考虑 (v2.0+):**
- 可以添加"智能建议"功能，推荐更好的标签名
- 实现标签批量重命名（如批量添加前缀/后缀）
- 添加标签模板（如icon-{n}, {type}-{n}等）
- 考虑支持标签分组（使用/分隔，如"home/icon-1"）
- 或者实现标签命名规范检查（如kebab-case、camelCase）

#### C. 严格验证
**描述:** 包括保留字检查、长度限制、特殊字符转码等

**优点:**
- 最严格

**缺点:**
- 可能过于复杂
- 用户体验差

**为什么不选择:**
- 标准验证已经足够
- 避免过度限制

---

### 决策 27: 图片格式支持范围

### 问题
支持哪些图片格式？

### 最终选择
**PNG + JPG + WebP** - 支持最常见的位图格式和现代格式

### 备选方案

#### A. 仅PNG + JPG
**描述:** 只支持最常见的格式

**优点:**
- 最简单
- 满足大多数AI工具输出

**缺点:**
- WebP越来越普及
- 限制用户选择

**为什么不选择:**
- WebP是现代标准
- Canvas原生支持
- 没有理由不支持

**未来考虑 (v2.0+):**
- 可以添加AVIF支持（下一代图片格式，比WebP更小）
- 考虑支持SVG输入（矢量到矢量，无需重新矢量化）
- 如果用户需求强烈，可以添加GIF支持（仅第一帧）
- 添加HEIC支持（iOS默认格式，需要额外库）
- 或者实现格式转换功能（自动转换不支持格式）

#### B. 全部支持
**描述:** 使用Canvas API支持的所有格式（BMP、GIF等）

**优点:**
- 最多支持

**缺点:**
- GIF可能有动画问题
- BMP很少用
- 可能导致问题

**为什么不选择:**
- 专注于常见格式
- 避免边界情况

---

### 决策 28: 响应式设计范围

### 问题
如何处理不同屏幕尺寸？

### 最终选择
**仅桌面** - 只优化桌面体验，平板和手机显示提示推荐使用桌面

### 备选方案

#### A. 桌面+平板
**描述:** 主要优化桌面，但平板可用

**优点:**
- 覆盖更多设备

**缺点:**
- 平板体验一般
- 增加适配工作

**为什么不选择:**
- 目标用户主要在桌面工作
- 设计师通常使用大屏
- 聚焦体验

**未来考虑 (v2.5+):**
- 如果数据显示>30%用户使用平板，可以优化平板体验
- 平板优化主要是调整触摸目标大小和布局适配
- 移动端需要完全重新设计UI（可能作为独立产品）
- 或者实现PWA，支持安装到桌面/平板
- 考虑使用响应式框架（如Tailwind的responsive modifier）降低适配成本

#### C. 全响应式
**描述:** 完整支持桌面、平板、手机

**优点:**
- 最全面

**缺点:**
- 大量适配工作
- 移动端使用场景少

**为什么不选择:**
- 图标编辑不适合移动端
- 开发成本高
- 桌面体验优先

---

## 技术决策矩阵总结

| 决策点 | 最终选择 | 关键原因 | 重新考虑时机 |
|--------|----------|----------|--------------|
| WebAssembly库 | VTracer | 支持彩色，文档完善 | 遇到严重问题时 |
| 状态持久化 | 不持久化 | 保持简单，减少复杂度 | 用户强烈需求时 |
| Worker并发数 | 4个 | 平衡性能和资源 | 低端设备反馈卡顿时 |
| 图片存储 | Canvas引用 | 平衡内存和性能 | 大图片导致问题时 |
| 撤销历史 | 5步 | 覆盖大多数错误 | 用户反馈不够时 |
| SVG清理 | 不清理 | 自生成无XSS风险 | 安全漏洞时 |
| 错误监控 | 不监控 | 保护隐私 | 发布后需要追踪时 |
| 测试范围 | 核心算法 | 速度与质量平衡 | 出现回归问题时 |
| ZIP导出 | JSZip | 成熟稳定 | 体积成问题时 |
| Canvas优化 | 不优化 | MVP简单优先 | 性能问题时 |
| 质量阈值 | 宽松 | 适合AI图标 | 误报率过高时 |
| 进度粒度 | 分步进度 | 信息透明 | 用户反馈信息过载时 |
| 撤销范围 | 边界框历史 | 最易错的操作 | 需要更多撤销时 |
| 标签验证 | 标准验证 | 平衡安全和体验 | 验证问题时 |
| 图片格式 | PNG+JPG+WebP | 常见+现代 | 其他格式需求强烈时 |
| 响应式 | 仅桌面 | 聚焦体验 | 移动端需求强烈时 |
